calls_out_n = dplyr::n_distinct(.data$TARGET),
.groups = "drop"
)
calls_in <- edges |>
dplyr::group_by(.data$TARGET) |>
dplyr::summarise(
called_by   = list(sort(unique(.data$SOURCE))),
calls_in_n  = dplyr::n_distinct(.data$SOURCE),
.groups = "drop"
)
} else {
calls_out <- tibble::tibble(SOURCE = character(), calls = list(), calls_out_n = integer())
calls_in  <- tibble::tibble(TARGET = character(), called_by = list(), calls_in_n = integer())
}
by_function <- nodes |>
dplyr::transmute(function_name = .data$name, file = .data$file) |>
dplyr::left_join(calls_out, by = c("function_name" = "SOURCE")) |>
dplyr::left_join(calls_in,  by = c("function_name" = "TARGET")) |>
dplyr::mutate(
calls       = dplyr::coalesce(.data$calls,     list(character(0))),
called_by   = dplyr::coalesce(.data$called_by, list(character(0))),
calls_out_n = dplyr::coalesce(.data$calls_out_n, 0L),
calls_in_n  = dplyr::coalesce(.data$calls_in_n,  0L)
) |>
dplyr::arrange(.data$file, .data$function_name)
by_file <- by_function |>
dplyr::group_by(.data$file) |>
dplyr::summarise(
functions       = list(sort(.data$function_name)),
n_functions     = dplyr::n(),
total_calls_out = sum(.data$calls_out_n),
total_calls_in  = sum(.data$calls_in_n),
.groups = "drop"
) |>
dplyr::arrange(.data$file)
list(
by_function  = by_function,
by_file      = by_file,
by_file_list = .as_file_nested_list(by_function)
)
}
map <- pkg_function_map(pkg_report)
# Or specify the fallback explicitly:
# map <- pkg_function_map(pkg_report, fallback_dir = "R")
map$by_function  # per-function view
map$by_file
pkg_report
# small helper if you don't already have it in scope
.as_file_nested_list <- function(by_function_tbl) {
split_rows <- split(by_function_tbl, by_function_tbl$file)
lapply(split_rows, function(df) {
out <- vector("list", nrow(df))
names(out) <- df$function_name
for (i in seq_len(nrow(df))) {
out[[i]] <- list(calls = df$calls[[i]], called_by = df$called_by[[i]])
}
out
})
}
pkg_function_map <- function(pkg_report, internal_only = TRUE, fallback_dir = NULL) {
fr <- pkg_report$FunctionReporter
nodes <- as.data.frame(fr$nodes, stringsAsFactors = FALSE)
if (!nrow(nodes)) stop("pkgnet FunctionReporter has no nodes; did analysis run?", call. = FALSE)
# find a file/path column if present
cand <- intersect(c("file","filename","path","filepath","source_file"), names(nodes))
file_col <- if (length(cand)) cand[which.max(vapply(cand, function(c) sum(nzchar(as.character(nodes[[c]]))), integer(1)))] else NA_character_
if (!length(file_col) || !any(nzchar(as.character(nodes[[file_col]])))) file_col <- NA_character_
# pkg root: try $pkg_path > attr > ""
pkg_root <- tryCatch(pkg_report$pkg_path, error = function(e) NULL)
if (is.null(pkg_root) || !length(pkg_root) || is.na(pkg_root)) {
pkg_root <- tryCatch(attr(pkg_report, "pkg_path"), error = function(e) NULL)
}
if (is.null(pkg_root) || !length(pkg_root) || is.na(pkg_root)) pkg_root <- ""
pkg_root_norm <- gsub("\\\\", "/", pkg_root)
# build nodes$file
if (!is.na(file_col)) {
file_path <- gsub("\\\\", "/", as.character(nodes[[file_col]]))
if (nzchar(pkg_root)) {
file_rel <- sub(paste0("^", pkg_root_norm, "/"), "", file_path)
} else {
file_rel <- file_path
}
nodes$file <- ifelse(nzchar(file_rel), file_rel, file_path)
} else {
# fallback to static parse of an R/ directory
if (is.null(fallback_dir) || !nzchar(fallback_dir)) {
fallback_dir <- if (nzchar(pkg_root)) file.path(pkg_root, "R") else "R"
}
lst <- functions_in_dir(fallback_dir)  # file -> char vec of fn names
fun2file <- if (length(lst)) {
files <- names(lst)
fns   <- unlist(lst, use.names = FALSE)
setNames(rep(files, lengths(lst)), fns)
} else setNames(character(0), character(0))
nodes$file <- unname(fun2file[nodes$name])
nodes$file[is.na(nodes$file) | !nzchar(nodes$file)] <- "(unknown)"
}
# edges (may be empty)
edges <- as.data.frame(fr$edges, stringsAsFactors = FALSE)
pkg_funcs <- nodes$name
if (nrow(edges) && isTRUE(internal_only)) {
edges <- edges[edges$SOURCE %in% pkg_funcs & edges$TARGET %in% pkg_funcs, , drop = FALSE]
}
if (nrow(edges)) {
calls_out <- edges |>
dplyr::group_by(.data$SOURCE) |>
dplyr::summarise(calls = list(sort(unique(.data$TARGET))),
calls_out_n = dplyr::n_distinct(.data$TARGET),
.groups = "drop")
calls_in <- edges |>
dplyr::group_by(.data$TARGET) |>
dplyr::summarise(called_by = list(sort(unique(.data$SOURCE))),
calls_in_n = dplyr::n_distinct(.data$SOURCE),
.groups = "drop")
} else {
calls_out <- tibble::tibble(SOURCE = character(), calls = list(), calls_out_n = integer())
calls_in  <- tibble::tibble(TARGET = character(), called_by = list(), calls_in_n = integer())
}
by_function <- nodes |>
dplyr::transmute(function_name = .data$name, file = .data$file) |>
dplyr::left_join(calls_out, by = c("function_name" = "SOURCE")) |>
dplyr::left_join(calls_in,  by = c("function_name" = "TARGET")) |>
dplyr::mutate(
calls       = dplyr::coalesce(.data$calls,     list(character(0))),
called_by   = dplyr::coalesce(.data$called_by, list(character(0))),
calls_out_n = dplyr::coalesce(.data$calls_out_n, 0L),
calls_in_n  = dplyr::coalesce(.data$calls_in_n,  0L)
) |>
dplyr::arrange(.data$file, .data$function_name)
by_file <- by_function |>
dplyr::group_by(.data$file) |>
dplyr::summarise(
functions       = list(sort(.data$function_name)),
n_functions     = dplyr::n(),
total_calls_out = sum(.data$calls_out_n),
total_calls_in  = sum(.data$calls_in_n),
.groups = "drop"
) |>
dplyr::arrange(.data$file)
list(
by_function  = by_function,
by_file      = by_file,
by_file_list = .as_file_nested_list(by_function)
)
}
# Option A: pass a fallback R/ explicitly (simplest)
map <- pkg_function_map(pkg_report, fallback_dir = "R")
# Option B: rely on pkgnet metadata if available (works after the fix)
map <- pkg_function_map(pkg_report)
map$by_function
map$by_file
names(as.data.frame(pkg_report$FunctionReporter$nodes))
utils::str(head(as.data.frame(pkg_report$FunctionReporter$nodes), 2))
# expects you already have functions_in_dir(dir) from earlier
pkg_function_map <- function(pkg_report, r_dir = "R", internal_only = TRUE) {
fr <- pkg_report$FunctionReporter
# --- functions defined in *your* package (pkgnet nodes) ---
nodes <- as.data.frame(fr$nodes, stringsAsFactors = FALSE)
if (!nrow(nodes)) stop("pkgnet FunctionReporter has no nodes; did analysis run?", call. = FALSE)
name_col <- if ("name" %in% names(nodes)) "name" else if ("node" %in% names(nodes)) "node" else NA_character_
if (is.na(name_col)) stop("Couldn't find a function-name column in FunctionReporter$nodes.")
func_names <- as.character(nodes[[name_col]])
# --- map functions -> files by parsing your R/ directory ---
lst <- functions_in_dir(r_dir)  # returns list: file -> character vector of function names
fun2file <- if (length(lst)) {
setNames(rep(names(lst), lengths(lst)), unlist(lst, use.names = FALSE))
} else setNames(character(0), character(0))
file_vec <- unname(fun2file[func_names])
file_vec[is.na(file_vec) | !nzchar(file_vec)] <- "(unknown)"
# base "by_function" frame
by_function <- data.frame(
function_name = func_names,
file          = file_vec,
stringsAsFactors = FALSE
)
# --- edges: function call graph (SOURCE -> TARGET) ---
edges <- as.data.frame(fr$edges, stringsAsFactors = FALSE)
if (nrow(edges)) {
if (isTRUE(internal_only)) {
keep_src <- edges$SOURCE %in% func_names
keep_tgt <- edges$TARGET %in% func_names
edges <- edges[keep_src & keep_tgt, , drop = FALSE]
}
} else {
# ensure 0-row data.frame has the columns we expect
edges <- data.frame(SOURCE = character(0), TARGET = character(0), stringsAsFactors = FALSE)
}
# Build adjacency lists (outgoing + incoming) using base R
split_targets <- if (nrow(edges)) split(edges$TARGET, edges$SOURCE) else list()
split_sources <- if (nrow(edges)) split(edges$SOURCE, edges$TARGET) else list()
calls_list <- lapply(by_function$function_name, function(fn) {
x <- split_targets[[fn]]
if (is.null(x)) character(0) else sort(unique(x))
})
called_by_list <- lapply(by_function$function_name, function(fn) {
x <- split_sources[[fn]]
if (is.null(x)) character(0) else sort(unique(x))
})
by_function$calls       <- calls_list
by_function$called_by   <- called_by_list
by_function$calls_out_n <- vapply(calls_list, length, integer(1))
by_function$calls_in_n  <- vapply(called_by_list, length, integer(1))
# Order rows (file, then function)
o <- order(by_function$file, by_function$function_name)
by_function <- by_function[o, ]
# --- per-file summary + nested list ---
split_by_file <- split(by_function, by_function$file)
files <- names(split_by_file)
by_file <- data.frame(
file            = files,
n_functions     = vapply(split_by_file, nrow, integer(1)),
total_calls_out = vapply(split_by_file, function(df) sum(df$calls_out_n), integer(1)),
total_calls_in  = vapply(split_by_file, function(df) sum(df$calls_in_n), integer(1)),
stringsAsFactors = FALSE
)
by_file$functions <- I(lapply(split_by_file, function(df) sort(df$function_name)))
by_file <- by_file[order(by_file$file), ]
by_file_list <- lapply(split_by_file, function(df) {
setNames(
lapply(seq_len(nrow(df)), function(i) {
list(calls = df$calls[[i]], called_by = df$called_by[[i]])
}),
df$function_name
)
})
list(
by_function  = by_function,
by_file      = by_file,
by_file_list = by_file_list
)
}
# You already have pkg_report
# pkg_report <- pkgnet::CreatePackageReport(pkg_name = "yourpkg")
# Point r_dir to your package's R/ folder
map <- pkg_function_map(pkg_report, r_dir = "R")
map$by_function   # one row per function + calls/called_by
map$by_file       # one row per file + list of functions + counts
# Example lookup:
# map$by_file_list[["providers_local.R"]][["request_local"]]$calls
# You already have pkg_report
# pkg_report <- pkgnet::CreatePackageReport(pkg_name = "yourpkg")
# Point r_dir to your package's R/ folder
map <- pkg_function_map(pkg_report, r_dir = "R")
map$by_function   # one row per function + calls/called_by
map$by_file       # one row per file + list of functions + counts
# Example lookup:
# map$by_file_list[["providers_local.R"]][["request_local"]]$calls
# You already have pkg_report
# pkg_report <- pkgnet::CreatePackageReport(pkg_name = "yourpkg")
# Point r_dir to your package's R/ folder
map <- pkg_function_map(pkg_report, r_dir = "R")
map$by_function   # one row per function + calls/called_by
map$by_file       # one row per file + list of functions + counts
# Example lookup:
# map$by_file_list[["providers_local.R"]][["request_local"]]$calls
map$by_function
map$by_function %>% tibble
library(tidyverse)
map$by_function %>% tibble
map$by_function %>% head()
map$by_file %>% head()
map$by_file %>% rownames()
map$by_file %>% `rownames<-`(NULL)
map$by_file %>% `rownames<-`(NULL) %>% view
map$by_file %>% `rownames<-`(NULL) %>% tibble %>% view
map$by_file$functions[[1]]
map$by_file$functions[[2]]
functions_table()
devtools::document()
usethis::use_roxygen_md()
roxygen2md::roxygen2md()
devtools::document()
load_all()
library(devtools)
install_github("FrancescoMonti-source/fmckage")
#' Summarise binary and categorical variables across groups
#'
#' Create a descriptive table of binary and categorical variables, stratified by
#' a grouping variable (with 2+ levels). For each \emph{variable × level},
#' the function reports \code{"N/total (xx.x%)"} per group and overall ("Total").
#'
#' @param data A data frame with one row per subject.
#' @param group_col Bare column name of the grouping variable.
#' @param vars Optional character vector of variable names to include. If NULL,
#'   variables are auto-detected as categorical when they have
#'   \code{<= cat_max_levels} distinct non-missing values after coercion.
#' @param exclude Optional character vector of columns to drop before detection.
#' @param cat_max_levels Integer; maximum distinct non-missing values to treat
#'   a variable as categorical (default 10). Binary is a special case (2 levels).
#' @param na_mode One of \code{"exclude"} (default) or \code{"include"}.
#'   If \code{"exclude"}, denominators are non-missing counts within each group
#'   for non-missing levels. If \code{"include"}, denominators use all rows in
#'   the group. The "(Missing)" level (when enabled) is always computed over
#'   the full group size.
#' @param include_missing Logical; if \code{TRUE} (default) add a "(Missing)"
#'   level per variable with \code{N/total (xx.x%)} where
#'   \code{total = group size}.
#' @param digits Integer; decimal places for percentages (default 1).
#' @param group_order Optional vector specifying the order of group columns.
#'   If \code{NULL}, factor levels are respected, otherwise natural sort.
#' @param group_labels Optional named character vector mapping raw group values
#'   to pretty labels. Unmapped groups keep their raw label.
#' @param level_order Optional named list: each element is a vector giving the
#'   desired order of levels for a specific variable
#'   (e.g. \code{list(smoker = c("No","Former","Yes"))}).
#' @param level_labels Optional named list: each element is a named character
#'   vector mapping raw levels to pretty labels for that variable
#'   (e.g. \code{list(smoker = c("0"="No","1"="Yes"))}).
#'
#' @return A tibble with one row per \code{variable × level} (including an
#'   optional "(Missing)" level) and one column per group plus "Total", each
#'   cell formatted as \code{"N/total (xx.x%)"}.
#'
#' @details
#' - Detection: a variable is considered categorical if, after coercion
#'   (\code{as.character()} for factors; numerics kept as-is),
#'   it has \code{<= cat_max_levels} distinct non-missing values.
#' - For non-missing levels, the denominator is controlled by \code{na_mode}.
#'   For the "(Missing)" line, the denominator is always the group size
#'   (so you can read missingness as a fraction of the whole group).
#'
#' @examples
#' set.seed(1)
#' df <- data.frame(
#'   grp = factor(sample(c("NS","SI","SA"), 120, TRUE)),
#'   diab = rbinom(120, 1, 0.2),
#'   stage = factor(sample(c("I","II","III","IV", NA), 120, TRUE)),
#'   smoke = sample(c("No","Former","Yes", NA), 120, TRUE)
#' )
#'
#' # Default: exclude NA from denominators for non-missing levels, add (Missing) line
#' make_group_table_mixed(df, group_col = grp)
#'
#' # Include NA in denominators, custom group/level ordering and labels
#' make_group_table_mixed(
#'   df, group_col = grp, na_mode = "include",
#'   group_order = c("NS","SI","SA"),
#'   group_labels = c(NS="non_suicidaires", SI="suicidaires_I", SA="suicidaires_A"),
#'   level_order = list(stage = c("I","II","III","IV")),
#'   level_labels = list(smoke = c("No"="Non","Former"="Ex","Yes"="Oui"))
#' )
#'
#' @export
make_group_table_mixed <- function(data,
group_col,
vars = NULL,
exclude = NULL,
cat_max_levels = 10,
na_mode = c("exclude","include"),
include_missing = TRUE,
digits = 1,
group_order = NULL,
group_labels = NULL,
level_order = NULL,
level_labels = NULL) {
na_mode  <- match.arg(na_mode)
group_sym <- rlang::ensym(group_col)
group_str <- rlang::as_string(group_sym)
# --- helper: choose variables ---
df0 <- data %>%
{ if (!is.null(exclude)) dplyr::select(., -tidyselect::all_of(exclude)) else . }
if (is.null(vars)) {
# auto-detect categorical (<= cat_max_levels unique non-missing)
keep <- vapply(df0, function(x) {
ux <- unique(stats::na.omit(if (is.factor(x)) as.character(x) else x))
length(ux) <= cat_max_levels
}, logical(1))
vars <- setdiff(names(df0)[keep], group_str)
}
df <- df0 %>%
dplyr::select(!!group_sym, tidyselect::all_of(vars))
# group sizes (for na_mode == "include" and for Missing line)
n_by_group <- df %>%
dplyr::count(!!group_sym, name = "n_group")
# tidy long; keep raw values
long <- tidyr::pivot_longer(df, -!!group_sym,
names_to = "variable", values_to = "raw")
# optional per-variable label mapping
map_level_labels <- function(var, x) {
lab_map <- if (!is.null(level_labels) && !is.null(level_labels[[var]])) level_labels[[var]] else NULL
if (is.null(lab_map)) x else dplyr::coalesce(lab_map[as.character(x)], as.character(x))
}
# counts per variable × group × level (incl. NA as own stratum for later)
counts <- long %>%
dplyr::group_by(variable, !!group_sym, level = raw) %>%
dplyr::summarise(N = dplyr::n(), .groups = "drop")
# non-missing and missing per variable × group
miss_summ <- long %>%
dplyr::group_by(variable, !!group_sym) %>%
dplyr::summarise(nonmiss = sum(!is.na(raw)),
miss = sum(is.na(raw)), .groups = "drop") %>%
dplyr::left_join(n_by_group, by = group_str)
# merge totals into counts
counts <- counts %>%
dplyr::left_join(miss_summ, by = c("variable", group_str))
# compute totals and pct by level
counts <- counts %>%
dplyr::mutate(
is_missing_level = is.na(level),
total = dplyr::case_when(
is_missing_level ~ n_group,                              # Missing row uses full group size
na_mode == "exclude" ~ nonmiss,
TRUE ~ n_group
),
pct = 100 * N / dplyr::if_else(total > 0, total, NA_real_),
level = ifelse(is_missing_level & include_missing, "(Missing)", as.character(level))
)
# drop the NA level entirely if not including Missing
if (!isTRUE(include_missing)) {
counts <- dplyr::filter(counts, !is_missing_level)
}
# Overall (everyone): sum over groups per variable × level
overall <- counts %>%
dplyr::group_by(variable, level) %>%
dplyr::summarise(
!!group_str := "everyone",
N = sum(N),
nonmiss = sum(nonmiss, na.rm = TRUE),
miss = sum(miss, na.rm = TRUE),
n_group = sum(n_group, na.rm = TRUE),
.groups = "drop"
) %>%
dplyr::mutate(
is_missing_level = (level == "(Missing)"),
total = dplyr::case_when(
is_missing_level ~ n_group,
na_mode == "exclude" ~ nonmiss,
TRUE ~ n_group
),
pct = 100 * N / dplyr::if_else(total > 0, total, NA_real_)
)
# combine and format
all_levels <- dplyr::bind_rows(
counts %>% dplyr::mutate(!!group_str := as.character(!!group_sym)) %>%
dplyr::select(variable, level, !!group_str, N, total, pct),
overall %>%
dplyr::select(variable, level, !!group_str, N, total, pct)
)
# group ordering
grp_vals <- data[[group_str]]
if (is.null(group_order)) {
group_order <- if (is.factor(grp_vals)) levels(grp_vals) else sort(unique(grp_vals))
}
group_order_chr <- as.character(group_order)
# pivot to wide (N/total (pct)) by group
wide <- tidyr::pivot_wider(
all_levels,
id_cols = c(variable, level),
names_from = !!rlang::sym(group_str),
values_from = c(N, total, pct),
names_glue = "{.value}_{.name}"
)
fmt <- function(n, t, p) {
ifelse(is.na(p), sprintf("%d/%d (NA)", n, t),
sprintf(paste0("%d/%d (%.", digits, "f%%)"), n, t, p))
}
# Determine which group suffixes exist
have_groups <- sub("^N_", "", grep("^N_", names(wide), value = TRUE))
# Column order: requested order (intersect) + any extras
ordered_groups <- c(intersect(group_order_chr, have_groups),
setdiff(have_groups, group_order_chr))
# Pretty group labels
label_of_group <- function(g) {
if (!is.null(group_labels) && !is.null(group_labels[[g]])) group_labels[[g]] else g
}
# Build display columns for each group
for (g in ordered_groups) {
Ncol <- paste0("N_", g); Tcol <- paste0("total_", g); Pcol <- paste0("pct_", g)
lbl  <- label_of_group(g)
wide[[lbl]] <- if (all(c(Ncol,Tcol,Pcol) %in% names(wide)))
fmt(wide[[Ncol]], wide[[Tcol]], wide[[Pcol]])
else NA_character_
}
# Total column (overall)
wide[["Total"]] <- if (all(c("N_everyone","total_everyone","pct_everyone") %in% names(wide))) {
fmt(wide[["N_everyone"]], wide[["total_everyone"]], wide[["pct_everyone"]])
} else NA_character_
# Apply per-variable level ordering/labels
out <- wide %>%
dplyr::mutate(
level = purrr::pmap_chr(
list(variable, level),
function(v, lv) {
mapped <- map_level_labels(v, lv)
ifelse(is.na(lv) & include_missing, "(Missing)", mapped)
}
)
)
if (!is.null(level_order)) {
out <- out %>%
dplyr::group_by(variable) %>%
dplyr::arrange(
dplyr::across(level, ~ {
ord <- level_order[[unique(variable)]]
if (is.null(ord)) match(.x, unique(.x)) else match(.x, ord)
}),
.by_group = TRUE
) %>%
dplyr::ungroup()
}
# final column ordering
final_cols <- c("variable", "level",
vapply(ordered_groups, label_of_group, character(1)),
"Total")
out %>%
dplyr::select(dplyr::all_of(final_cols))
}
library(fmckage)
find_in_sources("|>")
find_in_sources("\\|\\>")
install.packages("roxygen2")
install.packages("httr2")
