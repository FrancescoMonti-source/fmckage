round(200.1/4200,8)
round(200.1/4200,8)/100
280/48
280/38
280/35
280/15
280/20
2*6^2
2*6*6
2*2*3*2*3
2^3*6^2
2^3*3^2
6 * sqrt(2)
sqrt(72)
sqrt(15)
sqrt(20)
sqrt(300)
sqrt(20)*sqrt(15)
sqrt(39)
sqrt(21)
sqrt(45)
sqrt(19)
(3*sqrt(2))^2
sqrt(sqrt(4+9)^2+36)
sqrt(17^2-15^2)
sqrt(36+49)
sqrt(9+49)
sqrt(35-sqrt(5))
sqrt(34-sqrt(5))
sqrt(34-25
)
sqrt(15^2+6^2)
getwd()
export_package_functions("fmckage","C:/Users/francesco.monti/Documents/fmckage.R")
library(tidyverse)
28*7
2800/3800
3033/3813
1700+500+1350+939+900+550+85+99+250+99+99+99+120+120+68+240+80+150+1300+620+316+500+200+360+950+160+116+230+450
library(tidyverse)
export_package_functions("fmckage","fmckage.R")
library(pkgnet)
# Analyze your package
pkg_report <- CreatePackageReport(pkg_name = "fmckage")
# View the function network
pkg_report$FunctionReporter$PlotNetwork()
pkg_report$FunctionReporter$edges
library(pkgnet)
# Analyze your package
pkg_report <- CreatePackageReport(pkg_name = "gptr")
# View the function network
pkg_report$FunctionReporter$PlotNetwork()
pkg_report$FunctionReporter$edges
pkg_function_map <- function(pkg_report, internal_only = TRUE) {
fr <- pkg_report$FunctionReporter
# --- nodes: functions defined in *this* package (with file metadata) ----
nodes <- as.data.frame(fr$nodes)
if (!nrow(nodes)) {
stop("pkgnet report has no FunctionReporter nodes; did analysis run?", call. = FALSE)
}
# locate the file column present in your pkgnet version
file_col <- intersect(c("file", "filename", "path"), names(nodes))[1]
if (length(file_col) != 1) {
stop("Couldn't find a file/filename/path column in pkgnet FunctionReporter$nodes.", call. = FALSE)
}
# package root (for relative paths)
pkg_root <- attr(pkg_report, "pkg_path")
pkg_root <- tryCatch(normalizePath(pkg_root, winslash = "/", mustWork = FALSE), error = function(e) pkg_root)
nodes$file_path <- gsub("\\\\", "/", nodes[[file_col]])
nodes$file_rel  <- sub(paste0("^", gsub("\\\\", "/", pkg_root), "/"), "", nodes$file_path)
nodes$file_rel[!nzchar(nodes$file_rel)] <- nodes$file_path  # fallback if root missing
# --- edges: function call graph -----------------------------------------
edges <- as.data.frame(fr$edges)
if (!nrow(edges)) {
# degenerate case: no edges; still return per-file listing
by_function <- tibble::tibble(
function_name = nodes$name,
file         = nodes$file_rel,
calls        = replicate(nrow(nodes), character(0), simplify = FALSE),
called_by    = replicate(nrow(nodes), character(0), simplify = FALSE),
calls_out_n  = integer(nrow(nodes)),
calls_in_n   = integer(nrow(nodes))
)
by_file <- by_function |>
dplyr::group_by(file) |>
dplyr::summarise(
functions       = list(sort(function_name)),
n_functions     = dplyr::n(),
total_calls_out = 0L,
total_calls_in  = 0L,
.groups = "drop"
) |>
dplyr::arrange(file)
return(list(
by_function = by_function,
by_file     = by_file,
by_file_list = .as_file_nested_list(by_function)
))
}
# keep only internal edges if requested
pkg_funcs <- nodes$name
if (isTRUE(internal_only)) {
edges <- edges[edges$SOURCE %in% pkg_funcs & edges$TARGET %in% pkg_funcs, , drop = FALSE]
}
# group edges to build list-cols of calls / called_by and counts
calls_out <- edges |>
dplyr::group_by(SOURCE) |>
dplyr::summarise(
calls       = list(sort(unique(TARGET))),
calls_out_n = dplyr::n_distinct(TARGET),
.groups = "drop"
)
calls_in <- edges |>
dplyr::group_by(TARGET) |>
dplyr::summarise(
called_by   = list(sort(unique(SOURCE))),
calls_in_n  = dplyr::n_distinct(SOURCE),
.groups = "drop"
)
# assemble per-function table
by_function <- nodes |>
dplyr::transmute(function_name = name, file = file_rel) |>
dplyr::left_join(calls_out, by = c("function_name" = "SOURCE")) |>
dplyr::left_join(calls_in,  by = c("function_name" = "TARGET")) |>
dplyr::mutate(
calls       = ifelse(vapply(calls,     is.null, logical(1)), list(character(0)), calls),
called_by   = ifelse(vapply(called_by, is.null, logical(1)), list(character(0)), called_by),
calls_out_n = dplyr::coalesce(calls_out_n, 0L),
calls_in_n  = dplyr::coalesce(calls_in_n,  0L)
) |>
dplyr::arrange(file, function_name)
# per-file summary
by_file <- by_function |>
dplyr::group_by(file) |>
dplyr::summarise(
functions       = list(sort(function_name)),
n_functions     = dplyr::n(),
total_calls_out = sum(calls_out_n),
total_calls_in  = sum(calls_in_n),
.groups = "drop"
) |>
dplyr::arrange(file)
list(
by_function   = by_function,
by_file       = by_file,
by_file_list  = .as_file_nested_list(by_function)
)
}
# internal helper: turn by_function tibble into nested list: file -> function -> {calls, called_by}
.as_file_nested_list <- function(by_function_tbl) {
split_rows <- split(
by_function_tbl,
by_function_tbl$file
)
lapply(split_rows, function(df) {
out <- vector("list", nrow(df))
names(out) <- df$function_name
for (i in seq_len(nrow(df))) {
out[[i]] <- list(
calls     = df$calls[[i]],
called_by = df$called_by[[i]]
)
}
out
})
}
library(pkgnet)
pkg_report <- CreatePackageReport(pkg_name = "yourpkg")
map <- pkg_function_map(pkg_report)
map$by_function
map$by_file
library(pkgnet)
pkg_report <- CreatePackageReport(pkg_name = "fmckage")
map <- pkg_function_map(pkg_report)
map$by_function
map$by_file
# Requires the helpers: functions_in_dir() and .as_file_nested_list() from earlier
# Turn a by_function tibble into nested list: file -> function -> {calls, called_by}
.as_file_nested_list <- function(by_function_tbl) {
split_rows <- split(by_function_tbl, by_function_tbl$file)
lapply(split_rows, function(df) {
out <- vector("list", nrow(df))
names(out) <- df$function_name
for (i in seq_len(nrow(df))) {
out[[i]] <- list(calls = df$calls[[i]], called_by = df$called_by[[i]])
}
out
})
}
#' Build per-file and per-function maps from a pkgnet report (robust)
#' @param pkg_report Result of pkgnet::CreatePackageReport()
#' @param internal_only Keep only edges where SOURCE and TARGET are functions defined in your package
#' @param fallback_dir Directory to scan for R files if pkgnet provides no file metadata (default: package R/ if found)
#' @return list(by_function, by_file, by_file_list)
pkg_function_map <- function(pkg_report, internal_only = TRUE, fallback_dir = NULL) {
fr <- pkg_report$FunctionReporter
nodes <- as.data.frame(fr$nodes, stringsAsFactors = FALSE)
if (!nrow(nodes)) stop("pkgnet FunctionReporter has no nodes; did analysis run?", call. = FALSE)
# Try to find a column with file paths
cand_cols <- intersect(c("file", "filename", "path", "filepath", "source_file"), names(nodes))
file_col <- cand_cols[which.max(vapply(cand_cols, function(c) sum(nzchar(as.character(nodes[[c]]))), integer(1)))]
if (!length(file_col) || !any(nzchar(as.character(nodes[[file_col]])))) file_col <- NA_character_
# Package root (for pretty relative paths)
pkg_root <- attr(pkg_report, "pkg_path")
pkg_root <- tryCatch(normalizePath(pkg_root, winslash = "/", mustWork = FALSE), error = function(e) pkg_root)
pkg_root_norm <- gsub("\\\\", "/", pkg_root)
if (!is.na(file_col)) {
nodes$file_path <- gsub("\\\\", "/", as.character(nodes[[file_col]]))
nodes$file      <- sub(paste0("^", pkg_root_norm, "/"), "", nodes$file_path)
nodes$file[!nzchar(nodes$file)] <- nodes$file_path
} else {
# Fallback: build a function->file map by static parsing
if (is.null(fallback_dir)) {
if (nzchar(pkg_root)) fallback_dir <- file.path(pkg_root, "R") else fallback_dir <- "R"
}
lst <- functions_in_dir(fallback_dir)  # file -> char vec of names
# invert: function -> file
fun2file <- if (length(lst)) {
files <- names(lst)
fns   <- unlist(lst, use.names = FALSE)
setNames(rep(files, lengths(lst)), fns)
} else setNames(character(0), character(0))
nodes$file <- unname(fun2file[ nodes$name ])
nodes$file[is.na(nodes$file) | !nzchar(nodes$file)] <- "(unknown)"
}
# Edges (may be empty)
edges <- as.data.frame(fr$edges, stringsAsFactors = FALSE)
pkg_funcs <- nodes$name
if (nrow(edges) && isTRUE(internal_only)) {
edges <- edges[edges$SOURCE %in% pkg_funcs & edges$TARGET %in% pkg_funcs, , drop = FALSE]
}
# Build calls/called_by list-cols + counts
if (nrow(edges)) {
calls_out <- edges |>
dplyr::group_by(.data$SOURCE) |>
dplyr::summarise(
calls       = list(sort(unique(.data$TARGET))),
calls_out_n = dplyr::n_distinct(.data$TARGET),
.groups = "drop"
)
calls_in <- edges |>
dplyr::group_by(.data$TARGET) |>
dplyr::summarise(
called_by   = list(sort(unique(.data$SOURCE))),
calls_in_n  = dplyr::n_distinct(.data$SOURCE),
.groups = "drop"
)
} else {
calls_out <- tibble::tibble(SOURCE = character(), calls = list(), calls_out_n = integer())
calls_in  <- tibble::tibble(TARGET = character(), called_by = list(), calls_in_n = integer())
}
by_function <- nodes |>
dplyr::transmute(function_name = .data$name, file = .data$file) |>
dplyr::left_join(calls_out, by = c("function_name" = "SOURCE")) |>
dplyr::left_join(calls_in,  by = c("function_name" = "TARGET")) |>
dplyr::mutate(
calls       = dplyr::coalesce(.data$calls,     list(character(0))),
called_by   = dplyr::coalesce(.data$called_by, list(character(0))),
calls_out_n = dplyr::coalesce(.data$calls_out_n, 0L),
calls_in_n  = dplyr::coalesce(.data$calls_in_n,  0L)
) |>
dplyr::arrange(.data$file, .data$function_name)
by_file <- by_function |>
dplyr::group_by(.data$file) |>
dplyr::summarise(
functions       = list(sort(.data$function_name)),
n_functions     = dplyr::n(),
total_calls_out = sum(.data$calls_out_n),
total_calls_in  = sum(.data$calls_in_n),
.groups = "drop"
) |>
dplyr::arrange(.data$file)
list(
by_function  = by_function,
by_file      = by_file,
by_file_list = .as_file_nested_list(by_function)
)
}
map <- pkg_function_map(pkg_report)
# Or specify the fallback explicitly:
# map <- pkg_function_map(pkg_report, fallback_dir = "R")
map$by_function  # per-function view
map$by_file
pkg_report
# small helper if you don't already have it in scope
.as_file_nested_list <- function(by_function_tbl) {
split_rows <- split(by_function_tbl, by_function_tbl$file)
lapply(split_rows, function(df) {
out <- vector("list", nrow(df))
names(out) <- df$function_name
for (i in seq_len(nrow(df))) {
out[[i]] <- list(calls = df$calls[[i]], called_by = df$called_by[[i]])
}
out
})
}
pkg_function_map <- function(pkg_report, internal_only = TRUE, fallback_dir = NULL) {
fr <- pkg_report$FunctionReporter
nodes <- as.data.frame(fr$nodes, stringsAsFactors = FALSE)
if (!nrow(nodes)) stop("pkgnet FunctionReporter has no nodes; did analysis run?", call. = FALSE)
# find a file/path column if present
cand <- intersect(c("file","filename","path","filepath","source_file"), names(nodes))
file_col <- if (length(cand)) cand[which.max(vapply(cand, function(c) sum(nzchar(as.character(nodes[[c]]))), integer(1)))] else NA_character_
if (!length(file_col) || !any(nzchar(as.character(nodes[[file_col]])))) file_col <- NA_character_
# pkg root: try $pkg_path > attr > ""
pkg_root <- tryCatch(pkg_report$pkg_path, error = function(e) NULL)
if (is.null(pkg_root) || !length(pkg_root) || is.na(pkg_root)) {
pkg_root <- tryCatch(attr(pkg_report, "pkg_path"), error = function(e) NULL)
}
if (is.null(pkg_root) || !length(pkg_root) || is.na(pkg_root)) pkg_root <- ""
pkg_root_norm <- gsub("\\\\", "/", pkg_root)
# build nodes$file
if (!is.na(file_col)) {
file_path <- gsub("\\\\", "/", as.character(nodes[[file_col]]))
if (nzchar(pkg_root)) {
file_rel <- sub(paste0("^", pkg_root_norm, "/"), "", file_path)
} else {
file_rel <- file_path
}
nodes$file <- ifelse(nzchar(file_rel), file_rel, file_path)
} else {
# fallback to static parse of an R/ directory
if (is.null(fallback_dir) || !nzchar(fallback_dir)) {
fallback_dir <- if (nzchar(pkg_root)) file.path(pkg_root, "R") else "R"
}
lst <- functions_in_dir(fallback_dir)  # file -> char vec of fn names
fun2file <- if (length(lst)) {
files <- names(lst)
fns   <- unlist(lst, use.names = FALSE)
setNames(rep(files, lengths(lst)), fns)
} else setNames(character(0), character(0))
nodes$file <- unname(fun2file[nodes$name])
nodes$file[is.na(nodes$file) | !nzchar(nodes$file)] <- "(unknown)"
}
# edges (may be empty)
edges <- as.data.frame(fr$edges, stringsAsFactors = FALSE)
pkg_funcs <- nodes$name
if (nrow(edges) && isTRUE(internal_only)) {
edges <- edges[edges$SOURCE %in% pkg_funcs & edges$TARGET %in% pkg_funcs, , drop = FALSE]
}
if (nrow(edges)) {
calls_out <- edges |>
dplyr::group_by(.data$SOURCE) |>
dplyr::summarise(calls = list(sort(unique(.data$TARGET))),
calls_out_n = dplyr::n_distinct(.data$TARGET),
.groups = "drop")
calls_in <- edges |>
dplyr::group_by(.data$TARGET) |>
dplyr::summarise(called_by = list(sort(unique(.data$SOURCE))),
calls_in_n = dplyr::n_distinct(.data$SOURCE),
.groups = "drop")
} else {
calls_out <- tibble::tibble(SOURCE = character(), calls = list(), calls_out_n = integer())
calls_in  <- tibble::tibble(TARGET = character(), called_by = list(), calls_in_n = integer())
}
by_function <- nodes |>
dplyr::transmute(function_name = .data$name, file = .data$file) |>
dplyr::left_join(calls_out, by = c("function_name" = "SOURCE")) |>
dplyr::left_join(calls_in,  by = c("function_name" = "TARGET")) |>
dplyr::mutate(
calls       = dplyr::coalesce(.data$calls,     list(character(0))),
called_by   = dplyr::coalesce(.data$called_by, list(character(0))),
calls_out_n = dplyr::coalesce(.data$calls_out_n, 0L),
calls_in_n  = dplyr::coalesce(.data$calls_in_n,  0L)
) |>
dplyr::arrange(.data$file, .data$function_name)
by_file <- by_function |>
dplyr::group_by(.data$file) |>
dplyr::summarise(
functions       = list(sort(.data$function_name)),
n_functions     = dplyr::n(),
total_calls_out = sum(.data$calls_out_n),
total_calls_in  = sum(.data$calls_in_n),
.groups = "drop"
) |>
dplyr::arrange(.data$file)
list(
by_function  = by_function,
by_file      = by_file,
by_file_list = .as_file_nested_list(by_function)
)
}
# Option A: pass a fallback R/ explicitly (simplest)
map <- pkg_function_map(pkg_report, fallback_dir = "R")
# Option B: rely on pkgnet metadata if available (works after the fix)
map <- pkg_function_map(pkg_report)
map$by_function
map$by_file
names(as.data.frame(pkg_report$FunctionReporter$nodes))
utils::str(head(as.data.frame(pkg_report$FunctionReporter$nodes), 2))
# expects you already have functions_in_dir(dir) from earlier
pkg_function_map <- function(pkg_report, r_dir = "R", internal_only = TRUE) {
fr <- pkg_report$FunctionReporter
# --- functions defined in *your* package (pkgnet nodes) ---
nodes <- as.data.frame(fr$nodes, stringsAsFactors = FALSE)
if (!nrow(nodes)) stop("pkgnet FunctionReporter has no nodes; did analysis run?", call. = FALSE)
name_col <- if ("name" %in% names(nodes)) "name" else if ("node" %in% names(nodes)) "node" else NA_character_
if (is.na(name_col)) stop("Couldn't find a function-name column in FunctionReporter$nodes.")
func_names <- as.character(nodes[[name_col]])
# --- map functions -> files by parsing your R/ directory ---
lst <- functions_in_dir(r_dir)  # returns list: file -> character vector of function names
fun2file <- if (length(lst)) {
setNames(rep(names(lst), lengths(lst)), unlist(lst, use.names = FALSE))
} else setNames(character(0), character(0))
file_vec <- unname(fun2file[func_names])
file_vec[is.na(file_vec) | !nzchar(file_vec)] <- "(unknown)"
# base "by_function" frame
by_function <- data.frame(
function_name = func_names,
file          = file_vec,
stringsAsFactors = FALSE
)
# --- edges: function call graph (SOURCE -> TARGET) ---
edges <- as.data.frame(fr$edges, stringsAsFactors = FALSE)
if (nrow(edges)) {
if (isTRUE(internal_only)) {
keep_src <- edges$SOURCE %in% func_names
keep_tgt <- edges$TARGET %in% func_names
edges <- edges[keep_src & keep_tgt, , drop = FALSE]
}
} else {
# ensure 0-row data.frame has the columns we expect
edges <- data.frame(SOURCE = character(0), TARGET = character(0), stringsAsFactors = FALSE)
}
# Build adjacency lists (outgoing + incoming) using base R
split_targets <- if (nrow(edges)) split(edges$TARGET, edges$SOURCE) else list()
split_sources <- if (nrow(edges)) split(edges$SOURCE, edges$TARGET) else list()
calls_list <- lapply(by_function$function_name, function(fn) {
x <- split_targets[[fn]]
if (is.null(x)) character(0) else sort(unique(x))
})
called_by_list <- lapply(by_function$function_name, function(fn) {
x <- split_sources[[fn]]
if (is.null(x)) character(0) else sort(unique(x))
})
by_function$calls       <- calls_list
by_function$called_by   <- called_by_list
by_function$calls_out_n <- vapply(calls_list, length, integer(1))
by_function$calls_in_n  <- vapply(called_by_list, length, integer(1))
# Order rows (file, then function)
o <- order(by_function$file, by_function$function_name)
by_function <- by_function[o, ]
# --- per-file summary + nested list ---
split_by_file <- split(by_function, by_function$file)
files <- names(split_by_file)
by_file <- data.frame(
file            = files,
n_functions     = vapply(split_by_file, nrow, integer(1)),
total_calls_out = vapply(split_by_file, function(df) sum(df$calls_out_n), integer(1)),
total_calls_in  = vapply(split_by_file, function(df) sum(df$calls_in_n), integer(1)),
stringsAsFactors = FALSE
)
by_file$functions <- I(lapply(split_by_file, function(df) sort(df$function_name)))
by_file <- by_file[order(by_file$file), ]
by_file_list <- lapply(split_by_file, function(df) {
setNames(
lapply(seq_len(nrow(df)), function(i) {
list(calls = df$calls[[i]], called_by = df$called_by[[i]])
}),
df$function_name
)
})
list(
by_function  = by_function,
by_file      = by_file,
by_file_list = by_file_list
)
}
# You already have pkg_report
# pkg_report <- pkgnet::CreatePackageReport(pkg_name = "yourpkg")
# Point r_dir to your package's R/ folder
map <- pkg_function_map(pkg_report, r_dir = "R")
map$by_function   # one row per function + calls/called_by
map$by_file       # one row per file + list of functions + counts
# Example lookup:
# map$by_file_list[["providers_local.R"]][["request_local"]]$calls
# You already have pkg_report
# pkg_report <- pkgnet::CreatePackageReport(pkg_name = "yourpkg")
# Point r_dir to your package's R/ folder
map <- pkg_function_map(pkg_report, r_dir = "R")
map$by_function   # one row per function + calls/called_by
map$by_file       # one row per file + list of functions + counts
# Example lookup:
# map$by_file_list[["providers_local.R"]][["request_local"]]$calls
# You already have pkg_report
# pkg_report <- pkgnet::CreatePackageReport(pkg_name = "yourpkg")
# Point r_dir to your package's R/ folder
map <- pkg_function_map(pkg_report, r_dir = "R")
map$by_function   # one row per function + calls/called_by
map$by_file       # one row per file + list of functions + counts
# Example lookup:
# map$by_file_list[["providers_local.R"]][["request_local"]]$calls
map$by_function
map$by_function %>% tibble
library(tidyverse)
map$by_function %>% tibble
map$by_function %>% head()
map$by_file %>% head()
map$by_file %>% rownames()
map$by_file %>% `rownames<-`(NULL)
map$by_file %>% `rownames<-`(NULL) %>% view
map$by_file %>% `rownames<-`(NULL) %>% tibble %>% view
map$by_file$functions[[1]]
map$by_file$functions[[2]]
functions_table()
devtools::document()
usethis::use_roxygen_md()
roxygen2md::roxygen2md()
devtools::document()
load_all()
library(devtools)
install_github("FrancescoMonti-source/fmckage")
